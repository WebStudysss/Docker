## 1. 도커가 컨테이너 로그를 기본적으로 수집하는 대상은?

A. 컨테이너 내부의 `/var/log/*.log` 파일

B. 애플리케이션이 출력하는 stdout / stderr 스트림

C. 컨테이너 이미지의 레이어 변경 내역

D. 호스트 커널 메시지(dmesg)

---

## 2. 컨테이너가 종료된 뒤에도 `docker container logs`로 로그를 볼 수 있는 이유는?

A. 로그가 컨테이너 메모리에 영구 저장되기 때문

B. 도커가 stdout/stderr 내용을 JSON 로그 파일로 저장하기 때문

C. 도커가 로그를 항상 클라우드로 업로드하기 때문

D. 컨테이너가 종료되어도 프로세스가 백그라운드로 남기 때문

---

## 3. 도커의 기본 JSON 로그 파일에 대한 설명으로 옳은 것은?

A. 컨테이너 여러 개가 하나의 JSON 파일을 공유한다

B. 컨테이너마다 JSON 로그 파일이 생성되고 디스크가 찰 때까지 계속 커질 수 있다

C. JSON 로그는 항상 압축되어 저장된다

D. JSON 로그는 도커가 아닌 애플리케이션이 직접 관리한다

---

## 4. “표준 로그 모델”을 적용하기 어려운 경우로 가장 적절한 것은?

A. 애플리케이션이 stdout에 로그를 출력하는 경우

B. 애플리케이션이 syslog/윈도우 이벤트 로그 같은 외부 시스템에만 로그를 남기는 경우

C. 애플리케이션이 JSON 형식으로 로그를 출력하는 경우

D. 애플리케이션이 로그 레벨을 지원하는 경우

---

## 5. 로그 전달용 유틸리티(예: tail)가 하는 역할로 옳은 것은?

A. 로그 파일을 삭제해 디스크 사용량을 줄인다

B. 로그 파일 내용을 읽어 stdout으로 내보내 도커가 수집할 수 있게 한다

C. 도커 엔진 설정을 자동으로 수정한다

D. 컨테이너 로그를 자동으로 암호화한다

---

## 6. 로그 전달 유틸리티 방식의 단점으로 옳지 않은 것은?

A. 유틸리티가 포어그라운드로 실행되어 컨테이너 상태 판단을 꼬이게 할 수 있다

B. 애플리케이션이 죽어도 유틸리티가 살아있으면 컨테이너가 계속 실행될 수 있다

C. 헬스체크가 없어도 애플리케이션 이상을 항상 정확히 감지할 수 있다

D. 디스크 사용 효율이 떨어질 수 있다

---

## 7. 다음 중 Fluentd의 역할로 가장 적절한 것은?

A. 컨테이너를 스케일링하는 오케스트레이션 도구

B. 로그를 모아서 필터링/가공하고 여러 대상으로 포워딩하는 통합 로깅 계층

C. 로그를 JSON 파일로만 저장하는 도구

D. 로그를 화면에 출력하는 UI 도구

---

## 8. EFK 스택 구성 요소의 올바른 조합은?

A. Elasticsearch + Fluentd + Kibana

B. ElasticCache + Fluentbit + Kubernetes

C. Etcd + Fluentd + Kafka

D. Elasticsearch + Filebeat + Kinesis

---

## 9. Fluentd가 수집한 로그에 컨테이너 ID/이름 같은 메타데이터를 붙이는 이유는?

A. 로그를 암호화하기 위해

B. 로그 컨텍스트(어느 컨테이너/서비스에서 왔는지)를 파악하기 위해

C. 로그 용량을 줄이기 위해

D. 로그를 이미지에 다시 패키징하기 위해

---

## 10. 운영 환경에서 “애플리케이션 매니페스트(예: compose)”에 로깅 시스템을 명시적으로 지정하는 것이 좋은 이유는?

A. 도커 엔진 기본값은 항상 조직 정책과 같기 때문

B. 환경/배포 단위별로 로깅 동작을 재현 가능하게 하고 일관성을 확보하기 위해

C. 로깅 드라이버를 지정하면 네트워크 속도가 빨라지기 때문

D. stdout/stderr가 자동으로 비활성화되기 때문

---

# ✅ 정답 & 간단 해설

| 문제 | 정답 | 해설 |
| --- | --- | --- |
| 1 | **B** | 도커는 컨테이너 프로세스의 stdout/stderr를 수집함 |
| 2 | **B** | stdout/stderr가 호스트의 JSON 로그 파일로 저장되어 재조회 가능 |
| 3 | **B** | 컨테이너별 JSON 로그 파일이 생기고 기본 설정이면 계속 커질 수 있음 |
| 4 | **B** | stdout/stderr에 안 찍고 syslog/이벤트 로그만 쓰면 도커가 못 봄 |
| 5 | **B** | 파일 로그를 읽어 stdout으로 “전달”해서 도커가 수집하게 함 |
| 6 | **C** | 오히려 이상 감지가 어려워질 수 있음(헬스체크 없으면 특히) |
| 7 | **B** | Fluentd는 수집/필터/가공/포워딩 역할 |
| 8 | **A** | EFK = Elasticsearch(저장/검색) + Fluentd(수집) + Kibana(시각화) |
| 9 | **B** | “어느 컨테이너/서비스 로그인지” 컨텍스트가 필요함 |
| 10 | **B** | 배포 단위에서 로깅을 선언적으로 고정해야 재현성과 운영 일관성이 생김 |
