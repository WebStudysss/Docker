### 1. 도커 이미지 최적화가 필요한 주요 이유로 가장 적절한 것은?

A. 컨테이너 실행 속도를 느리게 하기 위해

B. 이미지 레이어를 강제로 병합하기 위해

C. 디스크 용량, 네트워크 트래픽, 보안을 개선하기 위해

D. Dockerfile 문법을 단순화하기 위해

---

### 2. 도커에서 이미지를 삭제하지 않으면 어떤 문제가 발생할 수 있는가?

A. 컨테이너가 자동으로 종료된다

B. 기존 이미지가 자동으로 덮어써진다

C. 디스크 용량이 계속 증가한다

D. 네트워크 포트 충돌이 발생한다

---

### 3. `docker system df` 명령어의 주요 용도는?

A. 실행 중인 컨테이너 목록 조회

B. 이미지 빌드 로그 확인

C. 도커 리소스의 디스크 사용량 확인

D. 캐시 레이어 초기화

---

### 4. Dockerfile에서 `rm` 명령으로 파일을 삭제해도 이미지 크기가 줄지 않는 이유는?

A. rm 명령은 컨테이너에서만 동작하기 때문에

B. 삭제된 파일이 메모리에 남아 있기 때문에

C. 이전 레이어에 파일이 그대로 남아 있기 때문에

D. Dockerfile이 캐시를 무시하기 때문에

---

### 5. 이미지 최적화를 위해 COPY 인스트럭션 사용 시 가장 바람직한 방법은?

A. 프로젝트 루트 전체를 COPY 한다

B. COPY 이후 RUN rm으로 불필요한 파일을 삭제한다

C. 꼭 필요한 디렉터리만 명시적으로 COPY 한다

D. COPY 대신 ADD를 항상 사용한다

---

### 6. `.dockerignore` 파일의 주요 목적은?

A. Dockerfile 문법 오류를 방지하기 위해

B. 빌드 컨텍스트에서 불필요한 파일을 제외하기 위해

C. 이미지 레이어를 병합하기 위해

D. 컨테이너 실행 속도를 높이기 위해

---

### 7. JDK 기반 이미지를 선택할 때 가벼운 이미지를 사용하는 이유로 옳은 것은?

A. 모든 기능이 자동으로 활성화되기 때문에

B. 컴파일 속도가 더 빨라지기 때문에

C. 이미지 크기 감소와 보안 공격 면적을 줄이기 위해

D. 멀티 스테이지 빌드를 사용할 수 없기 때문에

---

### 8. ‘골든 이미지(Golden Image)’에 대한 설명으로 가장 적절한 것은?

A. Docker Hub에서 공식 제공하는 이미지

B. 보안 취약점이 전혀 없는 이미지

C. 조직 내에서 표준으로 관리하는 기반 이미지

D. 멀티 스테이지 빌드에서만 사용하는 이미지

---

### 9. 멀티 스테이지 빌드를 사용하는 핵심 이유는?

A. Dockerfile 길이를 줄이기 위해

B. 컨테이너 실행 속도를 높이기 위해

C. 변경 가능성이 낮은 작업을 분리해 캐시 재사용성을 높이기 위해

D. 모든 레이어를 하나로 합치기 위해

---

### 10. Dockerfile에서 캐시를 최대한 활용하기 위한 인스트럭션 배치 전략으로 옳은 것은?

A. 자주 변경되는 인스트럭션을 앞쪽에 둔다

B. 모든 인스트럭션을 하나의 RUN으로 합친다

C. 자주 변경되는 인스트럭션을 뒤쪽에 둔다

D. COPY는 항상 마지막에 배치한다

---

---

## ✅ 정답 및 간단 해설

**1️⃣ 정답: C**

→ 이미지 최적화는 용량 감소, 네트워크 비용 절감, 보안성 향상이 핵심 목적이다.

**2️⃣ 정답: C**

→ 도커는 이미지를 자동으로 삭제하지 않으므로 디스크가 빠르게 찬다.

**3️⃣ 정답: C**

→ `docker system df`는 이미지, 컨테이너, 볼륨의 디스크 사용량을 보여준다.

**4️⃣ 정답: C**

→ 도커는 레이어 단위로 저장되므로 이전 레이어의 파일은 그대로 남는다.

**5️⃣ 정답: C**

→ 처음부터 필요한 파일만 COPY 해야 이미지 크기를 줄일 수 있다.

**6️⃣ 정답: B**

→ `.dockerignore`는 빌드 컨텍스트 자체를 줄이기 위한 도구다.

**7️⃣ 정답: C**

→ 불필요한 도구 제거는 이미지 크기 감소 + 공격 표면 축소 효과가 있다.

**8️⃣ 정답: C**

→ 골든 이미지는 조직 표준 기반 이미지로 일관성과 보안을 확보한다.

**9️⃣ 정답: C**

→ 의존성 다운로드처럼 변경이 적은 작업을 분리해 캐시 효율을 높인다.

**🔟 정답: C**

→ 자주 바뀌는 부분을 뒤에 둬야 앞 레이어 캐시를 재사용할 수 있다.
