지속적 통합(CI) 절차에서 도커를 활용하는 가장 직접적인 이유로 가장 적절한 것은? (11.1)
A. CI 서버의 메모리 사용량을 줄이기 위해서
B. 빌드 및 테스트 환경을 컨테이너로 고정해 재현성과 일관성을 확보하기 위해서
C. 애플리케이션 로그 수집을 간편하게 하기 위해서
D. 운영 서버 수를 자동으로 수평 확장하기 위해서

다음 중 도커 기반 CI 절차의 일반적인 단계 흐름으로 가장 적절한 것은? (11.1)
A. 테스트 → 빌드 → 릴리즈 이미지 생성 → 배포
B. 소스코드 체크아웃 → 도커 이미지 빌드 → 컨테이너에서 테스트 → 테스트 통과 시 이미지 푸시
C. 소스코드 체크아웃 → 운영 서버에 직접 배포 → 도커 이미지 백업 → 테스트
D. 도커 이미지 빌드 → 운영 서버에 수동 배포 → 테스트 → 코드 리뷰

도커를 이용해 빌드 인프라스트럭처를 구축할 때 얻을 수 있는 이점으로 올바른 것은? (11.2)
A. 빌드 서버마다 서로 다른 JDK 버전을 유지할 수 있다
B. 빌드 환경 구성을 수동 스크립트에만 의존하게 된다
C. 빌드 환경(툴체인, SDK 등)을 도커 이미지로 표준화하여 어디서든 동일한 빌드가 가능하다
D. 빌드 서버의 OS에 직접 패키지를 설치해야만 빌드를 실행할 수 있다

다음 중 도커 기반 빌드 인프라 설계 시 고려해야 할 요소로 보기 어려운 것은? (11.2)
A. 빌드 이미지의 베이스 이미지(JDK, Node 등) 선택
B. 빌드 캐시 활용 전략(레이어 캐시, 의존성 캐시 등)
C. 빌드 서버의 물리적 위치(국가, 데이터센터)
D. CI 서버에서 사용할 도커 레지스트리 주소 및 인증 방식

도커 컴포즈를 이용해 빌드 설정을 구성할 때의 장점으로 가장 적절한 것은? (11.3)
A. 한 번에 하나의 컨테이너만 실행할 수 있어 빌드 속도를 제어할 수 있다
B. 애플리케이션 빌드에 필요한 서비스(앱, DB, 메시지 브로커 등)를 하나의 설정 파일에서 정의하고 함께 올릴 수 있다
C. 도커 이미지를 사용하지 않고도 컨테이너를 구성할 수 있다
D. 운영 환경에서만 사용할 수 있고 CI 환경에서는 사용할 수 없다

다음 중 도커 컴포즈 파일에서 빌드 관련 설정으로 자주 사용하는 요소를 고른 것은? (11.3)
A. ports, volumes만 사용하고 build는 사용하지 않는다
B. build 섹션에서 Dockerfile 경로와 빌드 컨텍스트를 지정한다
C. depends_on만으로 모든 빌드 과정을 제어한다
D. restart 정책으로 테스트 통과 여부를 관리한다

“도커 외의 의존 모듈이 불필요한 CI 작업”을 설계하고자 한다. 이에 대한 설명으로 가장 알맞은 것은? (11.4)
A. CI 서버에 각종 SDK와 DB를 직접 설치해 두고, 도커는 결과만 저장하는 용도로 사용한다
B. 빌드와 테스트에 필요한 모든 의존성을 도커 이미지/컨테이너 안에 포함시켜, CI 서버에는 도커 엔진만 있으면 되게 한다
C. 운영 서버의 애플리케이션을 그대로 복제해서 CI 서버에서 실행한다
D. 도커 이미지를 사용하지 않고 호스트 OS에만 의존한다

다음 중 “도커 외의 의존 모듈이 불필요한 CI 작업”을 구현하는 데 도움이 되는 방식으로 가장 적절한 것은? (11.4)
A. CI 스크립트에서 apt-get install을 매번 실행한다
B. 테스트에 필요한 DB, 메시지 브로커 등을 모두 외부 SaaS 서비스로 연결한다
C. 애플리케이션, 빌드 도구, 테스트 도구, 의존 서비스까지 모두 컨테이너로 구성하고, CI는 이 컨테이너들을 조합해 작업을 수행한다
D. CI 서버의 글로벌 PATH에 모든 도구를 추가한다

다음 중 CI 파이프라인에 관계된 컨테이너로 보기 가장 어려운 것은? (11.5)
A. 애플리케이션 빌드 및 테스트를 수행하는 컨테이너
B. 테스트용 데이터베이스를 제공하는 컨테이너
C. CI 도구(Jenkins, GitLab Runner 등)를 실행하는 컨테이너
D. 운영 중인 실서비스 트래픽을 직접 받는 프로덕션 컨테이너만을 가리키는 경우

CI 파이프라인에서 여러 컨테이너를 조합해 테스트를 수행할 때, 컨테이너 간 관계를 정의하고 관리하는 대표적인 도구/기술 조합으로 가장 적절한 것은? (11.5, 11.6)
A. 도커 컴포즈를 이용해 CI 단계별로 필요한 컨테이너들을 정의하고, CI 툴에서 해당 컴포즈 파일을 실행한다
B. 각 컨테이너를 수동으로 docker run으로 실행하고, 관계는 문서로만 정리한다
C. 컨테이너 대신 VM을 사용하여 관계를 정의하지 않는다
D. CI 파이프라인과 컨테이너는 서로 독립적으로 동작해야 하므로 연동하지 않는다

정답 및 해설

정답: B

해설: 도커를 CI에 사용하면 빌드/테스트 환경을 이미지로 고정해 “어디서 돌려도 같은 결과”를 확보할 수 있다. 이는 지속적 통합의 핵심 요구사항인 재현성과 일관성을 만족시킨다. A, C, D는 부수적 효과이거나 CD(배포) 영역에 가까운 설명이다.

정답: B

해설: 일반적인 도커 기반 CI 흐름은 (1) 소스코드 체크아웃 → (2) 도커 이미지 빌드 → (3) 컨테이너에서 테스트 → (4) 테스트 통과 시 레지스트리 푸시 순서로 진행된다. A는 테스트와 빌드 순서가 뒤바뀌었고, C와 D는 운영 서버에 직접 배포하는 흐름이라 CI의 전형적인 패턴과 다르다.

정답: C

해설: 도커 기반 빌드 인프라의 핵심 장점은 빌드 환경을 컨테이너 이미지로 정의해서 어느 CI 서버에서든 동일한 환경을 재현할 수 있다는 점이다. A는 “서로 다른” 버전을 유지한다는 점에서 표준화와 반대이고, B와 D는 오히려 도커의 장점(자동화 및 추상화)을 무시한 설명이다.

정답: C

해설: 빌드 인프라 설계 시에는 어떤 베이스 이미지를 쓸지(A), 캐시를 어떻게 활용할지(B), 레지스트리와 인증을 어떻게 구성할지(D)가 중요하다. 물리적 위치(C)도 완전히 무시할 사항은 아니지만, 이 장의 “도커 기반 빌드 인프라스트럭처” 논의 핵심 요소로 보기에는 상대적으로 거리가 있다.

정답: B

해설: 도커 컴포즈를 사용하면 애플리케이션과 함께 빌드/테스트에 필요한 DB, 메시지 브로커 등 여러 서비스를 하나의 YAML 파일에서 정의하고 동시에 올릴 수 있다. A는 잘못된 설명이고, C는 도커 이미지를 사용하지 않는다는 모순이 있고, D는 CI 환경에서도 잘 사용 가능하다.

정답: B

해설: 도커 컴포즈에서 빌드 설정은 보통 build 섹션에 Dockerfile 경로와 컨텍스트를 지정하는 방식으로 한다. A는 build를 쓰지 않는다고 했고, C와 D는 빌드 설정과는 직접적인 관련이 없다. depends_on은 의존 관계 설정, restart는 재시작 정책이다.

정답: B

해설: “도커 외의 의존 모듈이 불필요한 CI 작업”이란, CI 서버에는 도커 엔진만 설치되어 있으면 되고, 실제 빌드와 테스트에 필요한 모든 도구와 의존성은 도커 이미지/컨테이너 안에 포함시키는 패턴을 말한다. A, C, D는 호스트나 운영 환경에 의존해 버려 이 목표와 다르다.

정답: C

해설: CI 단계에서 필요한 도구와 서비스(앱, 빌드 도구, 테스트 도구, DB 등)를 모두 컨테이너로 구성하면, CI 서버는 단순히 이 컨테이너들을 조합하는 역할만 수행하면 된다. A와 D는 호스트 의존성을 증가시키고, B는 외부 서비스에 연결하게 되어 “도커 외 의존 모듈 불필요”와는 거리가 있다.

정답: D

해설: CI 파이프라인에 관계된 컨테이너는 보통 빌드/테스트용 앱 컨테이너(A), 테스트 DB 컨테이너(B), CI 도구 컨테이너(C) 등을 포함한다. 반면 D처럼 오직 “실서비스 트래픽을 받는 프로덕션 컨테이너만”을 지칭하는 경우는 CI 파이프라인과 직접적인 관련이 있다고 보긴 어렵다.

정답: A

해설: 도커 컴포즈 파일에 테스트에 필요한 컨테이너 묶음을 정의해 두고, CI 툴이 해당 컴포즈 파일을 실행하는 방식이 11장 전체에서 다루는 “도커와 도커 컴포즈를 이용한 빌드 및 테스트”의 전형적인 조합이다. B는 수동 관리라 비효율적이고, C는 컨테이너를 쓰지 않으며, D는 CI와 컨테이너를 연동하지 않아 이 장의 취지와 반대다.
