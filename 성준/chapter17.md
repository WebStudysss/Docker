# 17장 도커 이미지 최적화하기: 보안, 용량, 속도 — 개념 확인 문제 (10문항, 4지선다)

## 문제

### 1) (17.1) 도커 이미지 최적화 방법으로 가장 적절한 조합은?
A. `FROM`를 여러 번 쓰고, 레이어는 최대한 많이 쪼갠다  
B. `.dockerignore`로 빌드 컨텍스트를 줄이고, 멀티 스테이지로 빌드 산출물만 남긴다  
C. 이미지 크기는 무시하고, 컨테이너 런타임 튜닝만 한다  
D. `latest` 태그만 사용해 최신 보안을 자동으로 보장한다  

---

### 2) (17.2) “좋은 기반 이미지(base image)”를 고를 때 가장 핵심 기준은?
A. 이미지에 기본 도구가 최대한 많이 포함되어 있을수록 좋다  
B. 이미지 크기가 크더라도 편의성이 높으면 무조건 좋다  
C. 필요한 구성요소만 포함해 공격 표면(attack surface)이 작고, 신뢰 가능한 출처의 이미지를 고른다  
D. 어떤 기반 이미지를 쓰든 보안은 런타임에서만 결정된다  

---

### 3) (17.2) 기반 이미지 선택과 관련해 재현성(빌드 결과 동일성)을 높이는 선택은?
A. 항상 `latest` 태그를 사용한다  
B. 동일 이미지라도 매번 다른 태그를 랜덤으로 쓴다  
C. 구체적인 버전 태그(또는 더 엄격하게는 digest 고정)를 사용한다  
D. 태그는 의미가 없으니 생략한다  

---

### 4) (17.3) “이미지 레이어 수와 이미지 크기는 최소한으로”라는 목표에 가장 직접적으로 기여하는 Dockerfile 작성 습관은?
A. `RUN`을 최대한 잘게 나누어 레이어를 많이 만든다  
B. 한 번 설치한 패키지 캐시/임시파일을 남겨둔다  
C. 관련 작업을 하나의 `RUN`으로 묶고, 캐시/임시파일을 정리해 레이어에 남지 않게 한다  
D. `COPY . .`는 언제나 최선이므로 항상 전체를 먼저 복사한다  

---

### 5) (17.3) 도커 이미지 “크기”를 줄이면서 동시에 “빌드 속도”에도 유리한 대표적인 방법은?
A. `.dockerignore`로 불필요한 파일을 빌드 컨텍스트에서 제외한다  
B. 레이어를 늘려서 캐시를 더 많이 쓰게 만든다  
C. 모든 파일을 한 번에 복사해 캐시를 무력화한다  
D. 빌드할 때마다 `--no-cache`를 기본으로 사용한다  

---

### 6) (17.4) 멀티 스테이지 빌드의 핵심 목적을 가장 정확히 설명한 것은?
A. 빌드 단계와 실행 단계를 분리해, 실행 이미지에는 “실행에 필요한 산출물만” 남긴다  
B. 실행 이미지를 더 크게 만들어 디버깅 도구를 풍부하게 포함한다  
C. 레이어를 더 많이 만들어 네트워크 전송을 느리게 한다  
D. 멀티 스테이지는 보안과 무관하고 오직 편의 기능이다  

---

### 7) (17.4) 멀티 스테이지 빌드에서 흔히 사용하는 패턴으로 올바른 것은?
A. 빌드 스테이지에서 만든 결과물을 런타임 스테이지로 복사하고, 빌드 도구는 런타임에 포함하지 않는다  
B. 런타임 스테이지에서 컴파일까지 모두 수행해 스테이지 수를 줄인다  
C. 빌드 산출물뿐 아니라 소스코드 전체를 런타임에 그대로 포함한다  
D. 스테이지를 나누면 캐시가 완전히 사라져 매번 전체 빌드가 강제된다  

---

### 8) (17.5) 이미지 최적화가 “보안”에 중요한 이유로 가장 적절한 것은?
A. 이미지가 작으면 무조건 해킹이 불가능하다  
B. 포함된 패키지/도구가 줄어들면 잠재 취약점/공격 표면이 줄어든다  
C. 보안은 오직 네트워크 방화벽으로만 결정된다  
D. 최적화는 속도에만 영향을 주고 보안과는 무관하다  

---

### 9) (17.5) 이미지 최적화가 “속도”에 중요한 이유로 가장 적절한 것은?
A. 이미지가 작으면 CPU 연산이 자동으로 빨라진다  
B. 이미지가 작으면 네트워크 전송/풀(pull) 시간이 줄어 배포/스케일아웃이 빨라진다  
C. 이미지가 크면 캐시가 더 잘 먹어서 항상 배포가 빨라진다  
D. 속도는 오직 애플리케이션 코드 품질로만 결정된다  

---

### 10) (17.6) 다음 중 “용량 + 보안 + 배포 속도”를 동시에 개선할 가능성이 가장 큰 변경은?
A. 런타임 이미지에 디버거, 패키지 매니저, 컴파일러를 모두 포함한다  
B. 실행에 필요 없는 파일을 `.dockerignore`로 제외하고, 멀티 스테이지로 런타임 이미지를 최소화한다  
C. 태그를 `latest`로 통일해 관리 부담을 없앤다  
D. 레이어를 늘리고 파일을 여기저기 분산 복사한다  

---

## 정답 & 해설 (한 번에 확인)

1) **B**  
- `.dockerignore`로 빌드 컨텍스트를 줄이면 불필요한 파일이 이미지에 들어가는 것을 막아 **용량/빌드 속도**에 유리합니다.  
- 멀티 스테이지로 빌드 도구를 최종 이미지에서 제거하면 **용량/보안(공격 표면 감소)**에 유리합니다.

2) **C**  
- 기반 이미지 자체가 포함하는 패키지/도구가 많을수록 공격 표면이 커집니다.  
- “필요한 구성요소만” + “신뢰 가능한 출처(공식/검증된 이미지)”가 핵심입니다.

3) **C**  
- `latest`는 시점에 따라 내용이 바뀌어 재현성이 떨어집니다.  
- 구체 버전 태그(또는 digest 고정)는 빌드 결과를 안정적으로 만듭니다.

4) **C**  
- 관련 작업을 묶어 레이어 수를 줄이고, 캐시/임시파일을 정리하면 최종 레이어에 찌꺼기가 남지 않아 **이미지 크기**가 줄어듭니다.

5) **A**  
- 빌드 컨텍스트 자체를 줄이면 전송/압축/해제/복사 비용이 줄어 **빌드 속도**가 개선되고, 불필요 파일이 이미지에 들어갈 가능성도 줄어 **용량**에도 유리합니다.

6) **A**  
- 멀티 스테이지의 핵심은 “빌드 환경(툴체인)과 실행 환경(런타임)을 분리”해서 최종 이미지를 최소화하는 것입니다.

7) **A**  
- 빌드 스테이지(컴파일/패키징) → 런타임 스테이지(실행)로 산출물만 복사하는 것이 정석 패턴입니다.  
- 이렇게 하면 런타임 이미지에서 빌드 도구가 제거되어 **용량/보안**에 유리합니다.

8) **B**  
- 포함된 패키지/도구가 적을수록 취약점이 숨어 있을 표면이 줄어듭니다.  
- 즉, 최적화는 보안과 직결됩니다.

9) **B**  
- 이미지가 작으면 풀(pull) 시간이 줄어 배포가 빨라지고, 오토스케일/롤링 배포에서도 이점이 큽니다.

10) **B**  
- `.dockerignore` + 멀티 스테이지는 용량/보안/속도를 같이 잡는 대표 조합입니다.  
- 최종 이미지에는 “실행에 필요한 것만” 남기고, 불필요 파일/툴은 배제하는 방향이 정답입니다.
