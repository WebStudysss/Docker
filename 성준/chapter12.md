12장 컨테이너 오케스트레이션: 도커 스웜과 쿠버네티스 – 10문제
12-1 (12.1 컨테이너 오케스트레이션 도구란?)

컨테이너 오케스트레이션 도구의 역할로 가장 적절한 것은?

컨테이너 내부 애플리케이션의 비즈니스 로직을 자동으로 작성해 준다.

여러 컨테이너를 클러스터 환경에서 배치·확장·복구하고, 서비스 디스커버리와 네트워킹을 관리한다.

Dockerfile을 자동으로 생성해 준다.

소스 코드 버전을 관리하는 도구이다.

12-2 (12.2 도커 스웜으로 클러스터 만들기)

도커 스웜 클러스터를 최초로 생성할 때 사용하는 명령으로 가장 알맞은 것은?

docker swarm create

docker swarm init

docker swarm start

docker swarm cluster

12-3 (12.2 도커 스웜으로 클러스터 만들기)

스웜 클러스터에 새로운 워커 노드를 추가하려고 한다. 일반적인 절차로 가장 적절한 것은?

워커 노드에서 docker swarm join 명령을 사용하고, 매니저 노드가 제공한 토큰과 매니저 주소를 인자로 넘긴다.

워커 노드에서 docker run만 실행하면 자동으로 스웜에 합류한다.

매니저 노드에서 워커 노드 IP로 ssh 접속만 하면 자동으로 등록된다.

스웜 모드에서는 워커 노드를 추가할 수 없다.

12-4 (12.3 도커 스웜 서비스로 애플리케이션 실행하기)

도커 스웜에서 **서비스(Service)**를 사용하는 이유로 가장 적절한 것은?

단일 컨테이너를 수동으로 관리하기 위해

다수의 컨테이너(태스크)를 하나의 논리적 서비스 단위로 관리하고, 설정한 replica 수에 맞춰 자동으로 배치·복구하기 위해

로컬 개발 환경에서만 테스트하기 위해

컨테이너 로그를 삭제하기 위해

12-5 (12.3 도커 스웜 서비스로 애플리케이션 실행하기)

다음 명령에 대한 설명으로 가장 적절한 것은?

docker service create --name web --replicas 3 -p 80:80 nginx


nginx 이미지를 사용해 하나의 컨테이너만 실행한다.

web이라는 이름의 서비스가 생성되며, 3개의 레플리카 컨테이너가 클러스터 노드에 분산 배치된다.

이 명령은 스웜 모드가 아닐 때도 항상 실행된다.

포트 매핑은 각 컨테이너마다 직접 설정해야 한다.

12-6 (12.4 클러스터 환경에서 네트워크 트래픽 관리하기)

도커 스웜에서 오버레이(overlay) 네트워크를 사용하는 주된 이유로 가장 알맞은 것은?

단일 호스트 내부에서만 컨테이너를 연결하기 위해

여러 노드에 걸쳐 있는 컨테이너들끼리 논리적으로 같은 네트워크에 있는 것처럼 통신할 수 있도록 하기 위해

외부 인터넷 접근을 차단하기 위해

로깅 설정을 하기 위해

12-7 (12.4 클러스터 환경에서 네트워크 트래픽 관리하기)

도커 스웜의 라우팅 메쉬(Routing Mesh) 또는 인그레스(ingress) 네트워크에 대한 설명으로 가장 적절한 것은?

특정 노드에서만 서비스 포트를 열 수 있게 한다.

어느 노드로 요청이 들어와도, 스웜이 적절한 컨테이너로 트래픽을 라우팅해 주는 기능을 제공한다.

내부 DNS를 비활성화하는 기능이다.

로컬 Docker bridge 네트워크에서만 동작한다.

12-8 (12.5 도커 스웜과 쿠버네티스 중 무엇을 사용할까?)

다음 중 도커 스웜과 쿠버네티스를 비교한 설명으로 가장 적절한 것은?

쿠버네티스는 오케스트레이션 기능이 없고, 스웜만 오케스트레이션을 지원한다.

도커 스웜은 상대적으로 설정과 개념이 단순하며, 쿠버네티스는 더 풍부한 기능과 생태계를 제공하지만 학습 곡선이 더 가파르다.

도커 스웜은 프로덕션 환경에서 사용할 수 없다.

두 도구는 완전히 동일한 설정 파일과 API를 사용한다.

12-9 (12.5 도커 스웜과 쿠버네티스 중 무엇을 사용할까?)

다음 중 쿠버네티스를 선택해야 할 가능성이 높은 상황으로 가장 적절한 것은?

소규모 팀에서 간단한 몇 개의 서비스만 운영하며, 빠르게 오케스트레이션을 도입하고 싶다.

대규모 마이크로서비스 아키텍처, 다양한 워크로드, 풍부한 생태계(스토리지, 인그레스, 모니터링 연동 등)가 필요한 경우이다.

단일 호스트에서만 컨테이너를 실행할 예정이다.

오케스트레이션 없이 docker run으로만 운영하기를 원한다.

12-10 (12.1–12.6 통합 / 연습 관점)

다음은 애플리케이션을 컨테이너 오케스트레이션 환경에 배포하려는 팀의 요구사항이다.

여러 노드에 걸쳐 자동으로 애플리케이션을 배포하고, 장애 시 자동 복구 필요

서비스 디스커버리와 로드 밸런싱 필요

향후 쿠버네티스도 고려하지만, 우선은 도커 기반 클러스터로 시작하고 싶음

이 팀의 첫 단계 선택지로 가장 적절한 것은?

도커 스웜을 사용해 클러스터를 구성하고, 서비스 단위로 배포·확장을 관리한다.

docker run 스크립트를 여러 서버에 수동으로 배포한다.

오케스트레이션 없이 Dockerfile만 작성한다.

쿠버네티스를 사용하지만, 컨테이너 이미지는 사용하지 않는다.


📌 12장 정답 및 해설

12-1 정답: 2

컨테이너 오케스트레이션 도구의 역할은

클러스터에서 컨테이너 배치, 확장, 헬스체크, 복구, 서비스 디스커버리, 네트워킹을 관리하는 것이다.

1, 3, 4는 오케스트레이션 도구의 역할이 아니다.

12-2 정답: 2

스웜 클러스터를 최초로 초기화하는 명령은 docker swarm init 이다.

1, 3, 4는 실제 명령이 아니거나 올바른 초기화 명령이 아니다.

12-3 정답: 1

새로운 워커 노드는 매니저가 제공한 join 토큰과 매니저 주소를 사용해

워커에서 docker swarm join 명령으로 클러스터에 합류한다.

2, 3, 4는 스웜 구조를 잘못 이해한 설명.

12-4 정답: 2

스웜의 서비스는 다수의 컨테이너(태스크)를

하나의 논리적 단위로 관리하고, replica 수만큼 자동 배치/복구한다.

1, 3, 4는 서비스 개념과 맞지 않는다.

12-5 정답: 2

명령 설명:

web 서비스 생성

--replicas 3 → 3개의 컨테이너(태스크)가 스웜 노드에 분산

-p 80:80 → 클러스터 인그레스 포트 80 노출

1, 3, 4는 스웜 서비스의 동작을 제대로 반영하지 않는다.

12-6 정답: 2

오버레이 네트워크는 여러 노드에 분산된 컨테이너들을 논리적으로 같은 네트워크에 속한 것처럼 연결해준다.

1, 3, 4는 오버레이 네트워크의 목적과 다르다.

12-7 정답: 2

스웜의 라우팅 메쉬/ingress는

어느 노드로 요청이 와도, 스웜이 내부적으로 적절한 컨테이너로 트래픽을 라우팅해 주는 기능이다.

1, 3, 4는 라우팅 메쉬의 역할을 잘못 설명한 것.

12-8 정답: 2

일반적으로

도커 스웜: 개념과 설정이 비교적 단순, Docker와 밀접

쿠버네티스: 기능과 생태계가 매우 풍부, 그만큼 학습 곡선이 가파름

1, 3, 4는 사실과 다르다.

12-9 정답: 2

대규모 마이크로서비스, 다양한 워크로드, 스토리지/인그레스/모니터링 등 풍부한 생태계가 필요하면 쿠버네티스 선택 가능성이 높다.

1, 3, 4는 오케스트레이션 필요성이 낮거나 K8s의 장점을 활용하지 못하는 상황.

12-10 정답: 1

“도커 기반으로 시작하고 싶다 + 클러스터, 자동 배포/복구, 로드밸런싱 필요” →

도커 스웜으로 클러스터 구성 후 서비스 단위로 운영하는 것이 자연스러운 첫 단계다.

2, 3, 4는 오케스트레이션의 이점을 활용하지 못하거나 전제가 틀렸다.
