# 19장 도커를 이용한 로그 생성 및 관리 — 연습문제 (4지선다 10문항)

## 문제

### 1) (19.1) 컨테이너 로그 관점에서 표준 출력(stdout)과 표준 에러(stderr)에 대한 설명으로 가장 정확한 것은?
A. stdout/stderr는 도커가 자동으로 파일로 저장하며, 로깅 드라이버와 무관하다  
B. 애플리케이션은 stdout/stderr로 로그를 내보내고, 도커 엔진이 이를 수집해 로깅 드라이버로 전달한다  
C. stdout/stderr는 컨테이너 내부에서만 의미가 있고 `docker logs`로는 조회할 수 없다  
D. stdout/stderr 대신 반드시 syslog로 직접 보내야 컨테이너 로그가 수집된다

---

### 2) (19.1) 애플리케이션이 **일반 로그**와 **에러 로그**를 분리하고 싶을 때, 도커 로그 모델에 가장 자연스럽게 맞는 방식은?
A. 일반 로그/에러 로그 모두 `/var/log/app.log` 한 파일로만 기록한다  
B. 일반 로그는 stdout, 에러는 stderr로 출력한다  
C. 일반 로그는 stderr, 에러는 stdout로 출력한다  
D. 둘 다 도커 데몬 로그로 직접 기록한다

---

### 3) (19.2) 어떤 레거시 애플리케이션이 파일(`/var/log/app.log`)로만 로그를 쓴다. **도커의 기본 로그 수집 흐름에 태우려면** 가장 적절한 전략은?
A. 컨테이너를 privileged로 띄운 뒤 도커 데몬 설정 파일을 컨테이너에서 수정한다  
B. 파일 로그를 읽어 stdout으로 흘려보내는 브리지(전달) 구성을 만든다 (예: tail로 따라가 stdout으로 출력)  
C. `docker logs`가 파일을 자동으로 읽도록 도커에 파일 경로를 등록한다  
D. 파일 로그는 수집이 불가능하니 항상 호스트에서만 본다

---

### 4) (19.2) “다른 곳(파일/소켓 등)으로 출력된 로그를 stdout로 전달”할 때 주의해야 할 사항으로 가장 타당한 것은?
A. 전달 프로세스는 로그 파일이 커지면 자동으로 과거 로그를 지우므로 안전하다  
B. 전달 과정에서 중복 출력(같은 로그가 여러 번)이나 누락이 생기지 않도록 스트림/로테이션 경계를 고려해야 한다  
C. stdout로 전달하면 로그를 더 이상 중앙 수집으로 보낼 수 없다  
D. stdout로 전달하면 컨테이너 성능이 항상 크게 향상된다

---

### 5) (19.3) “컨테이너 로그 수집 및 포워딩” 흐름을 가장 올바르게 설명한 것은?
A. 컨테이너가 직접 중앙 로그 시스템에만 전송하며, 도커 엔진은 로그에 관여하지 않는다  
B. 컨테이너 stdout/stderr → 도커 엔진 수집 → 로깅 드라이버(또는 수집기)로 전달 → 외부 저장/분석 시스템  
C. 호스트 커널이 stdout/stderr를 자동으로 중앙 수집 시스템으로 전달한다  
D. `docker logs`는 외부 저장소에 저장된 로그를 다시 컨테이너로 되돌려 보여준다

---

### 6) (19.3) 로그를 **포워딩(전달)**하는 목적에 가장 부합하는 설명은?
A. 컨테이너를 재시작할 때마다 로그를 완전히 삭제하기 위해서  
B. 로그를 컨테이너 밖(외부 시스템)으로 보내 장기 보관/검색/분석/알림이 가능하게 하기 위해서  
C. 로그 크기를 줄여 컨테이너 이미지를 작게 만들기 위해서  
D. 네트워크 트래픽을 늘려 장애를 빨리 발견하기 위해서

---

### 7) (19.4) “로그 출력 및 로그 컬렉션 관리” 관점에서 가장 위험한 안티패턴은?
A. 애플리케이션 로그를 stdout/stderr로 내보낸다  
B. 로그량이 많아질 수 있는 이벤트에 대해 레벨/샘플링/필터링 정책을 둔다  
C. 무제한으로 로그를 쌓아두고 회전/보관 정책이 없다  
D. 로그 수집 실패 시 재시도/버퍼링 같은 전략을 고려한다

---

### 8) (19.4) 운영 환경에서 로그 관리 정책을 세울 때, **가장 합리적인 목표 조합**은?
A. 로그는 최대한 자세히 남기되, 보관 기간/회전 정책/검색 가능성을 함께 설계한다  
B. 로그는 무조건 최소화하고, 장애가 나면 그때부터 디버그 로그를 켠다(기록 없음)  
C. 로그는 컨테이너 내부 파일에만 남기고 외부로는 내보내지 않는다  
D. 로그는 이미지 빌드 단계에서만 생성하고 런타임에는 생성하지 않는다

---

### 9) (19.5) “컨테이너의 로깅 모델”을 가장 정확히 요약한 것은?
A. 컨테이너는 원칙적으로 stdout/stderr 스트림에 로그를 출력하고, 플랫폼이 이를 수집/전달하는 구조다  
B. 컨테이너는 시스템 서비스처럼 syslog를 강제 사용한다  
C. 컨테이너는 로그가 없어야 정상이며, 로그는 디버깅 시에만 임시로 만든다  
D. 컨테이너 로그는 반드시 컨테이너 내부 파일 시스템에만 저장된다

---

### 10) (19.5) `docker logs`로 확인 가능한 로그의 “근본적인 출처”로 가장 알맞은 것은?
A. 컨테이너 이미지 레이어에 포함된 빌드 로그  
B. 컨테이너에서 발생한 stdout/stderr 출력이 도커 엔진에 의해 기록된 것  
C. 호스트의 커널 메시지(dmesg)  
D. 오케스트레이터(쿠버네티스 등)가 생성한 이벤트 로그

---

## 정답 및 해설

### 1) 정답: B  
**해설:** 도커의 기본 로깅 흐름은 “컨테이너 프로세스의 stdout/stderr → 도커 엔진이 수집 → 설정된 로깅 드라이버로 저장/전달”이다. stdout/stderr가 핵심 인터페이스다.

### 2) 정답: B  
**해설:** 일반 로그는 stdout, 오류/경고 계열은 stderr로 분리하면, 스트림 레벨에서 구분 가능하고 수집·분석 파이프라인에서도 처리하기 쉽다.

### 3) 정답: B  
**해설:** 파일로만 남는 레거시 로그는 “파일 → stdout”으로 흘려보내는 전달(브리지) 계층을 두는 것이 도커의 표준 로그 수집 모델에 맞다. 도커가 임의의 파일 경로를 자동 수집하진 않는다.

### 4) 정답: B  
**해설:** 파일→stdout 전달은 로테이션(파일 교체), 파일 truncation, 재시작 시 오프셋 처리 등에서 **중복/누락**이 생기기 쉽다. 전달 메커니즘의 경계 조건을 고려해야 한다.

### 5) 정답: B  
**해설:** 컨테이너 stdout/stderr가 출발점이고, 도커 엔진이 이를 수집한 뒤 로깅 드라이버/수집기를 통해 외부 시스템으로 포워딩하는 형태가 일반적이다.

### 6) 정답: B  
**해설:** 포워딩의 목적은 컨테이너 수명과 무관하게 로그를 **외부에 안전하게 보관**하고, 검색/분석/알림까지 가능하게 만드는 것이다.

### 7) 정답: C  
**해설:** 회전/보관(retention) 정책 없이 무제한으로 쌓으면 디스크 고갈, 성능 저하, 장애 확산으로 이어진다. 운영 관점에서 가장 위험한 패턴이다.

### 8) 정답: A  
**해설:** 로그는 문제 해결을 위한 관측 데이터다. “충분한 정보 + 보관/회전/검색/접근 정책”이 같이 설계돼야 운영 비용과 장애 대응이 균형을 이룬다.

### 9) 정답: A  
**해설:** 컨테이너 로깅 모델의 핵심은 “애플리케이션은 stdout/stderr로 내보내고, 실행 플랫폼(도커)이 수집·전달한다”는 분리다.

### 10) 정답: B  
**해설:** `docker logs`는 컨테이너가 stdout/stderr로 내보낸 출력을 도커 엔진이 기록한 로그를 보여준다. 이미지 빌드 로그나 커널 로그가 아니다.
