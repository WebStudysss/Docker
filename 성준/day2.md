### 1) `docker build`가 전송하는 **빌드 컨텍스트**에 대해 옳은 것은?

A. Dockerfile이 있는 디렉터리만 보내며, 하위 디렉터리는 제외된다

B. 기본적으로 지정한 경로의 모든 파일·하위 폴더를 전송한다

C. 항상 50MB로 제한되어 자동 압축 전송한다

D. `--file`로 Dockerfile 경로를 바꾸면 컨텍스트도 그 경로가 된다

**정답: B**

해설: 컨텍스트는 **지정 경로 전체**다. 커다란 컨텍스트는 느려지므로 `.dockerignore`로 줄인다.

---

### 2) `.dockerignore`의 효과로 **가장 적절한 것**은?

A. 빌드 캐시를 비활성화한다

B. 컨테이너 실행 시 볼륨 마운트 제외 목록을 지정한다

C. 빌드 컨텍스트에서 제외해 **전송 용량과 레이어 변경**을 줄인다

D. 이미지를 푸시할 때 특정 레이어를 제거한다

**정답: C**

해설: 컨텍스트에서 **미포함** → 업로드 축소, **COPY/ADD 변경 최소화**로 캐시 적중률↑.

---

### 3) `COPY`와 `ADD`의 차이로 옳은 것은?

A. 둘 다 원격 URL을 지원한다

B. `ADD`는 tar 아카이브 자동 해제를 지원한다

C. `COPY`는 빌드 시점에만 동작하고 `ADD`는 런타임에 동작한다

D. `ADD`는 항상 더 안전하다

**정답: B**

해설: `ADD`만 **tar 자동 해제/URL** 가능. 보안·예측성 위해 **대부분 `COPY` 권장**.

---

### 4) `ARG`와 `ENV`의 차이로 옳은 것은?

A. `ARG`는 컨테이너 런타임 환경변수, `ENV`는 빌드 시 변수

B. 둘 다 런타임에서만 접근 가능

C. `ARG`는 빌드 단계에서만 사용, `ENV`는 이미지에 **영구 반영**되어 런타임에도 노출

D. 차이가 없다

**정답: C**

해설: `ARG`=빌드용, `ENV`=이미지 메타로 남아 **컨테이너 실행 시에도 사용**.

---

### 5) **멀티스테이지 빌드**를 사용하는 주된 목적은?

A. Docker Hub 푸시 속도 향상

B. 레이어 수를 1개로 합치기

C. **빌드 도구/의존성은 이전 단계에 두고, 최종 이미지는 실행 산출물만 포함**해 **용량↓ 보안↑**

D. 런타임 성능 극대화

**정답: C**

해설: `FROM builder …` → `FROM runtime … COPY --from=builder …` 패턴으로 **슬림 이미지**.

---

### 6) 다음 Dockerfile 중 **캐시 활용**을 가장 잘 고려한 순서는?

A. `RUN npm install` → `COPY package.json` → `COPY . .`

B. `COPY . .` → `RUN npm install` → `RUN npm run build`

C. `COPY package*.json .` → `RUN npm ci` → `COPY . .` → `RUN npm run build`

D. `RUN npm run build` → `COPY . .` → `RUN npm ci`

**정답: C**

해설: **의존성 목록 먼저 복사**해 캐시 적중률↑, 이후 소스 전체 복사.

---

### 7) `ENTRYPOINT`와 `CMD`의 조합 설명 중 옳은 것은?

A. `ENTRYPOINT`와 `CMD`가 함께 있을 때 **CMD는 기본 인자** 역할을 한다

B. 둘이 함께 있으면 `ENTRYPOINT`가 무시된다

C. `CMD`가 있으면 `ENTRYPOINT`는 필요 없다

D. `ENTRYPOINT`는 `docker run` 인자로 덮어쓸 수 없다

**정답: A**

해설: `ENTRYPOINT`=실행 파일, `CMD`=**기본 인자**. 필요 시 `docker run`에서 인자로 덮어씀.

---

### 8) 이미지 태깅과 푸시에 대한 설명으로 옳은 것은?

A. `docker tag a b`는 이미지를 복제하여 디스크 사용량이 2배가 된다

B. `docker push repo:tag`는 해당 **태그**의 레이어만 업로드한다

C. 다이제스트(digest)는 가변적이므로 재현성 확보에 부적합하다

D. `latest`는 항상 최신 빌드를 의미한다

**정답: B**

해설: 태그는 **참조(별칭)**일 뿐 복제 아님. 푸시는 **필요한 레이어만** 전송. 재현성엔 **다이제스트** 고정 참조 권장.

---

### 9) 이미지 용량 최적화 관점에서 **틀린 것**은?

A. 멀티스테이지로 빌더와 러너를 분리한다

B. 불필요한 패키지 캐시/임시파일을 `RUN` 한 레이어에서 정리한다

C. `alpine`은 항상 최선이므로 glibc 기반 앱에도 무조건 쓴다

D. 언어별 런타임 전용 베이스(예: `python:slim`, distroless)를 고려한다

**정답: C**

해설: `alpine`은 **musl libc**라 glibc 기대 라이브러리와 호환 이슈 가능. 용도에 맞게 선택.

---

### 10) 다음 중 **빌드 실패/느려짐**을 야기할 가능성이 가장 큰 안티패턴은?

A. `.dockerignore`에 `node_modules/`, `.git/`를 포함

B. 단일 `RUN`에서 패키지 설치 후 캐시·임시파일 제거

C. 거대한 바이너리를 `ADD`로 URL에서 직접 내려받고, 자주 바뀌는 파일을 Dockerfile 상단에서 `COPY`

D. 멀티스테이지에서 `COPY --from=builder`로 산출물만 이동

**정답: C**

해설: **URL `ADD`는 예측성↓**, 자주 바뀌는 파일을 상단에 두면 **하위 캐시 전부 무효화**되어 빌드 느려짐.
