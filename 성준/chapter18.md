# 18장 컨테이너의 애플리케이션 설정 관리 — 4지선다 문제 10개

> 규칙: 각 문항은 정답 1개. **정답/해설은 문서 맨 아래**에만 있습니다.

---

## 1) 다단(멀티-티어) 애플리케이션 설정

### Q1. (18.1) 웹/API/워커로 구성된 다단 애플리케이션을 컨테이너로 배포할 때, **설정 관리의 핵심 원칙**으로 가장 적절한 것은?
A. 운영 환경별로 이미지 자체를 각각 따로 빌드해 배포한다  
B. 공통 설정은 모든 컨테이너에 동일 파일을 강제 복사해 넣는다  
C. 애플리케이션 이미지는 최대한 동일하게 유지하고, 환경 차이는 런타임에 주입한다  
D. 설정은 컨테이너 내부에 영구 저장해 재시작해도 유지되게 한다  

### Q2. (18.1) 같은 시스템 내 여러 컨테이너가 **동일한 설정 값(예: 외부 API base URL)을 참조**해야 한다. 가장 “컨테이너 친화적”인 접근은?
A. 각 이미지에 값을 하드코딩하고, 바뀌면 전부 다시 빌드한다  
B. 실행 시점에 동일 값을 각 컨테이너에 주입(환경변수/마운트 등)하고, 소스/이미지는 동일하게 유지한다  
C. 각 컨테이너가 부팅될 때 서로의 파일 시스템을 스캔해서 값을 가져온다  
D. 설정 값을 DB에 넣고, 시작할 때마다 DB 스키마를 자동 변경한다  

---

## 2) 환경별 설정 패키징

### Q3. (18.2) **개발/스테이징/운영** 3개 환경을 운영할 때, “같은 애플리케이션 이미지”를 최대한 재사용하면서 환경별 설정만 바꾸는 방식으로 가장 적절한 것은?
A. dev/stg/prod 별로 코드 브랜치를 유지하고 각각 빌드한다  
B. 애플리케이션 이미지는 동일하게 두고, 환경별 설정은 별도 아티팩트(파일/패키지)로 분리해 배포 시 결합한다  
C. 운영 환경은 성능을 위해 컨테이너가 아닌 VM에만 배포한다  
D. 운영만 예외적으로 설정을 이미지에 넣고 나머지는 런타임 주입한다  

### Q4. (18.2) 환경별 설정을 “이미지로 패키징”할 때 얻는 장점으로 가장 알맞은 것은?
A. 설정 변경이 발생해도 기존 이미지 레이어 캐시를 완전히 무시하고 항상 전체를 다시 빌드할 수 있다  
B. 설정도 버전 관리/배포 단위로 만들 수 있어, 환경별 설정 변경을 롤백/추적하기 쉽다  
C. 컨테이너 간 네트워크 통신이 필요 없어져서 보안이 자동으로 해결된다  
D. 애플리케이션이 어떤 환경에서든 동일한 DB 스키마를 자동 생성하게 된다  

---

## 3) 런타임에서 설정 읽어 들이기

### Q5. (18.3) 컨테이너 런타임에 설정을 주입했는데, 애플리케이션이 **“프로세스 시작 시점에만” 설정 파일을 읽는 레거시 방식**이다. 가장 현실적인 해결 전략은?
A. 컨테이너를 실행해 둔 채로 파일을 바꾸면 앱이 자동 반영되니 신경 쓰지 않는다  
B. 컨테이너 시작 시 엔트리포인트/스타트업 스크립트로 설정 파일을 생성/치환한 뒤 앱을 실행한다  
C. 애플리케이션 바이너리를 컨테이너 밖으로 복사해서 호스트에서 실행한다  
D. 설정 파일을 /tmp에 저장하면 모든 앱이 자동으로 읽는다  

### Q6. (18.3) 아래 중 “런타임 설정 주입”의 대표적 특성을 가장 잘 설명한 것은?
A. 설정은 이미지에 들어가야 하므로 실행 중엔 변경할 수 없다  
B. 동일 이미지를 다양한 환경에 재사용하기 쉬우며, 배포 시점에 값이 결정된다  
C. 런타임 주입은 반드시 소스코드 수정이 필요하다  
D. 런타임 주입을 하면 컨테이너 재시작이 불가능해진다  

---

## 4) 레거시 애플리케이션에 설정 전략 적용

### Q7. (18.4) 레거시 앱이 설정을 **특정 경로(/app/config.yml)** 에서만 읽는다. 컨테이너 환경에서 가장 무난한 적용 방법은?
A. 해당 경로에 맞춰 설정 파일을 마운트(또는 시작 시 생성)해서 경로 호환성을 유지한다  
B. 앱 코드를 수정하지 않고도 컨테이너가 자동으로 경로를 인식한다  
C. 이미지의 ENTRYPOINT를 제거하면 앱이 알아서 다른 경로를 스캔한다  
D. 설정 파일을 이미지에 넣되, 환경마다 컨테이너 이름을 다르게 하면 해결된다  

### Q8. (18.4) 레거시 앱이 “환경변수는 못 읽고 파일만 읽는다”. 그래도 런타임에 환경변수로 값을 주입하고 싶다. 가장 적절한 패턴은?
A. 환경변수 값을 컨테이너 네트워크로 브로드캐스트한다  
B. 시작 스크립트가 환경변수를 읽어 **설정 파일을 템플릿/생성**한 뒤 앱을 실행한다  
C. 애플리케이션 프로세스에 attach해서 메모리를 수정한다  
D. 호스트의 /etc/hosts를 수정하면 앱 설정이 자동으로 바뀐다  

---

## 5) 유연한 설정 모델의 이점

### Q9. (18.5) “유연한 설정 모델”의 대표적 이점으로 가장 적절한 것은?
A. 설정을 유연하게 하면 코드 성능이 자동으로 빨라진다  
B. 환경별 차이를 최소화해 **같은 아티팩트(이미지)를 승격(promote)** 하며 배포/롤백이 쉬워진다  
C. 설정을 분리하면 반드시 더 많은 레이어가 생겨 이미지 크기가 커진다  
D. 설정을 분리하면 컨테이너 오케스트레이션이 필요 없어진다  

### Q10. (18.5) 다단 애플리케이션에서 설정을 “기본값 + 환경값 + 인스턴스별 값”으로 계층화했다. 일반적으로 **우선순위(override)** 로 가장 타당한 것은?
A. 기본값 > 환경값 > 인스턴스별 값  
B. 환경값 > 기본값 > 인스턴스별 값  
C. 인스턴스별 값 > 환경값 > 기본값  
D. 인스턴스별 값 > 기본값 > 환경값  

---

# 정답 및 해설

- **Q1: C** — 컨테이너/이미지는 최대한 동일하게 유지하고, 환경 차이는 실행 시점에 주입하면 “같은 이미지 재사용”과 “환경별 배포 일관성”을 얻는다.  
- **Q2: B** — 여러 컨테이너가 같은 값을 써야 할 때는 각 컨테이너에 동일 값을 런타임 주입하는 방식이 일반적이다(코드/이미지 재빌드 최소화).  
- **Q3: B** — 환경별 설정을 별도 패키지/파일로 분리하고 배포 시 결합하면, 동일 이미지 승격 배포가 가능해지고 운영 리스크가 줄어든다.  
- **Q4: B** — 설정도 버전/배포 단위로 만들면 변경 이력 추적과 롤백이 쉬워진다(“설정이 곧 배포 아티팩트”).  
- **Q5: B** — 레거시 앱은 “시작 시 설정 파일 로드”가 많다. 따라서 시작 단계에서 파일을 생성/치환 후 앱 실행이 가장 현실적이다.  
- **Q6: B** — 런타임 주입의 본질은 “배포 시점에 값 결정” + “동일 이미지 재사용”이다.  
- **Q7: A** — 레거시 경로 제약은 바꾸기 어렵다. 컨테이너에서 그 경로에 맞춰 파일을 제공(마운트/생성)하는 게 가장 안전하다.  
- **Q8: B** — 환경변수 → 템플릿 → 설정 파일 생성 패턴은 “레거시 호환 + 런타임 주입”을 동시에 만족한다.  
- **Q9: B** — 같은 이미지로 dev→stg→prod 승격이 가능해지고, 문제 시 이전 설정/조합으로 빠르게 롤백할 수 있다.  
- **Q10: C** — 보통 가장 구체적인 값이 최우선이다(인스턴스별 > 환경별 > 기본값). 충돌 시 override 규칙이 명확해진다.

---

## 참고 자료(공식 문서 위주)
- [Docker Docs - Environment variables](https://docs.docker.com/compose/environment-variables/) : 컨테이너/서비스에 환경변수 주입 개념
- [Docker Docs - Use volumes](https://docs.docker.com/storage/volumes/) : 설정 파일을 마운트하는 대표 방법(볼륨)
- [Docker Docs - Bind mounts](https://docs.docker.com/storage/bind-mounts/) : 호스트 파일을 컨테이너 경로에 직접 연결(레거시 경로 호환에 자주 사용)
- [Docker Docs - ENTRYPOINT](https://docs.docker.com/reference/dockerfile/#entrypoint) : 시작 시점에 설정 파일 생성/치환 같은 “부트스트랩”을 넣을 때 핵심
